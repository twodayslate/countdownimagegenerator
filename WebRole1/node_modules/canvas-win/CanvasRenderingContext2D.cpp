#include "stdafx.h"

#include "v8helper.h"
#include "ImageSource.h"
#include "Image.h"
#include "Canvas.h"
#include "CanvasRenderingContext2D.h"
#include "CanvasGradient.h"
#include "CssColors.h"
#include "TextMetrics.h"
#include "CanvasPattern.h"
#include <algorithm>

using namespace v8;
using namespace node;
using namespace node::canvas;

const WCHAR* node::canvas::LineJoinRound = L"round";
const WCHAR* node::canvas::LineJoinBevel = L"bevel";
const WCHAR* node::canvas::LineJoinMiter = L"miter";
const WCHAR* node::canvas::LineCapButt= L"butt";
const WCHAR* node::canvas::LineCapRound = L"round";
const WCHAR* node::canvas::LineCapSquare = L"square";
const WCHAR* node::canvas::TextAlignStart = L"start";
const WCHAR* node::canvas::TextAlignEnd = L"end";
const WCHAR* node::canvas::TextAlignCenter = L"center";
const WCHAR* node::canvas::TextAlignTop = L"top";
const WCHAR* node::canvas::TextAlignMiddle = L"middle";
const WCHAR* node::canvas::TextAlignBottom = L"bottom";


Persistent<FunctionTemplate> CanvasRenderingContext2D::constructor;
ULONG_PTR CanvasRenderingContext2D::gdiplusToken;

template<typename T>
void ModifyObjectAlpha(T *el, REAL alpha){
	Color color;
	el->GetColor(&color);
	Color newColor(color.GetA() * alpha, color.GetR(), color.GetG(), color.GetB());
	el->SetColor(newColor);
}

void ModifyLinearGradientBrush(LinearGradientBrush* brush, REAL alpha) {
	INT count = brush->GetInterpolationColorCount();
	Color *colors = new Color[count];
	REAL *points = new REAL[count];

	brush->GetInterpolationColors(colors, points, count);
	for(int i = 0; i < count; ++i) {
		Color& color = colors[i];
		colors[i] = Color(color.GetA() * alpha, color.GetR(), color.GetG(), color.GetB());
	}
	brush->SetInterpolationColors(colors, points, count);

	delete[] points;
	delete[] colors;
}


CanvasRenderingContext2D* CanvasRenderingContext2D::UnwrapContext(const Arguments& args){
	CanvasRenderingContext2D* context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->m_count++;
				
	return context;
}

int CanvasRenderingContext2D::GetEncoderClsid(const WCHAR* format, CLSID* pClsid)
{
	UINT  num = 0;          // number of image encoders
	UINT  size = 0;         // size of the image encoder array in bytes

	ImageCodecInfo* pImageCodecInfo = NULL;

	GetImageEncodersSize(&num, &size);
	if(size == 0)
		return -1;  // Failure

	pImageCodecInfo = (ImageCodecInfo*)(malloc(size));
	if(pImageCodecInfo == NULL)
		return -1;  // Failure

	GetImageEncoders(num, size, pImageCodecInfo);

	for(UINT j = 0; j < num; ++j)
	{
		if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 )
		{
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Success
		}    
	}

	free(pImageCodecInfo);
	return -1;  // Failure
}

void CanvasRenderingContext2D::EnsurePathCreated(){
	if(m_currentPath.get() == NULL){
		m_currentPath.reset(new GraphicsPath());		
	}
}

 CanvasRenderingContext2D::CanvasRenderingContext2D():m_count(0){
	
	m_pen.reset(new Pen(Color::Black));
	m_brush.reset(new SolidBrush(Color::Transparent));
	m_clearBrush.reset(new SolidBrush(Color(0,0,0,0)));
	m_font.reset(new Font(L"sans-serif", 10, 0, UnitPixel));
	m_stringFormat.reset(StringFormat::GenericTypographic()->Clone());	

	m_lineWidth = 1;
	m_globalAlpha = 1;

	int count = sizeof(cssColors) / sizeof(WCHAR*);
	for(int i = 0; i < count; i+=2){
		m_cssColors[std::wstring(cssColors[i])] = std::wstring(cssColors[i+1]);
	}

}

CanvasRenderingContext2D::~CanvasRenderingContext2D(){							
	
}

Gdiplus::Image* CanvasRenderingContext2D::GetImage(){
	return m_buffer.get();
}

void CanvasRenderingContext2D::Resize(UINT width, UINT height){
	m_buffer.reset(new Bitmap(width, height, PixelFormat32bppPARGB));
	m_graphics.reset(Graphics::FromImage(m_buffer.get()));
	m_pen.reset(new Pen(Color::Black));
	m_brush.reset(new SolidBrush(Color::Transparent));
	m_point = PointF(0, 0);
	
	//m_graphics->SetCompositingQuality(CompositingQualityHighQuality);
	m_graphics->SetInterpolationMode(InterpolationModeHighQualityBicubic);
	m_graphics->SetSmoothingMode(SmoothingModeAntiAlias);
}

void  CanvasRenderingContext2D::MoveTo(REAL x, REAL y){
	m_point = PointF(x, y);				
}

void  CanvasRenderingContext2D::Rect(REAL x, REAL y, REAL width, REAL height){
	this->EnsurePathCreated();
	m_currentPath->AddRectangle(Gdiplus::Rect(x,y, width, height));
	m_currentPath->GetLastPoint(&m_point);	
}

void CanvasRenderingContext2D::Arc(REAL x, REAL y, REAL radius, REAL startAngle, REAL stopAngle, bool anitclockwise){
	this->EnsurePathCreated();
	m_currentPath->AddArc(x-radius, y-radius, 2*radius, 2*radius, 180*startAngle/M_PI, 180*(!anitclockwise?(stopAngle-startAngle):(startAngle-stopAngle))/M_PI);
	m_currentPath->GetLastPoint(&m_point);
}

void  CanvasRenderingContext2D::LineTo(REAL x, REAL y){				
	this->EnsurePathCreated();
	m_currentPath->AddLine(m_point, PointF(x, y));				
	m_currentPath->GetLastPoint(&m_point);
}

void CanvasRenderingContext2D::QuadraticCurveTo(REAL cpx, REAL cpy, REAL x, REAL y){				
	this->BezierCurveTo(m_point.X, m_point.Y, cpx, cpy, x, y);
}

void CanvasRenderingContext2D::BezierCurveTo(REAL cp1x, REAL cp1y, REAL cp2x, REAL cp2y, REAL x, REAL y){				
	this->EnsurePathCreated();
	m_currentPath->AddBezier(m_point.X, m_point.Y, cp1x, cp1y, cp2x, cp2y, x, y);
	m_currentPath->GetLastPoint(&m_point);
}

void CanvasRenderingContext2D::Fill(){
	std::auto_ptr<Brush> oldBrush(m_brush->Clone());
	this->UpdateBrushWithGlobalAlpha();
	m_graphics->FillPath(m_brush.get(), m_currentPath.get());
	m_brush = oldBrush;	
}

void CanvasRenderingContext2D::Stroke(){	
	std::auto_ptr<Pen> oldPen(m_pen->Clone());
	ModifyObjectAlpha(m_pen.get(), m_globalAlpha);
	m_graphics->DrawPath(m_pen.get(), m_currentPath.get());				
	m_pen = oldPen;	
}

void CanvasRenderingContext2D::ClosePath(){
	m_currentPath->CloseFigure();
}

void  CanvasRenderingContext2D::BeginPath(){
	m_currentPath.release();
}

void CanvasRenderingContext2D:: Clip(){
	this->EnsurePathCreated();
	m_graphics->SetClip(m_currentPath.get());
}

void CanvasRenderingContext2D::Save(){
	SavedState* state = new SavedState();
	state->graphicsState = m_graphics->Save();
	state->brush.reset(m_brush->Clone());
	state->pen.reset(m_pen->Clone());
	state->font.reset(m_font->Clone());
	state->stringFormat.reset(m_stringFormat->Clone());
	state->lastPoint = m_point;
	state->lineWidth = m_lineWidth;
	state->globalAlpha = m_globalAlpha;
	m_states.push(state);
}

void CanvasRenderingContext2D::Restore(){
	SavedState* state = m_states.top();
	
	m_brush = state->brush;
	m_pen = state->pen;
	m_font = state->font;
	m_stringFormat = state->stringFormat;
	m_point = state->lastPoint;
	m_lineWidth = state->lineWidth;
	m_globalAlpha = state->globalAlpha;

	m_graphics->Restore(state->graphicsState);
	delete state;
	m_states.pop();
}

void CanvasRenderingContext2D::ClearRect(INT x, INT y, INT width, INT height){
	CompositingMode mode = m_graphics->GetCompositingMode();
	m_graphics->SetCompositingMode(CompositingModeSourceCopy);
	m_graphics->FillRectangle(m_clearBrush.get(), x, y, width, height);
	m_graphics->SetCompositingMode(mode);
}

void CanvasRenderingContext2D::UpdateBrushWithGlobalAlpha(){
	if (dynamic_cast<Gdiplus::SolidBrush*>(m_brush.get())) {		
		ModifyObjectAlpha((SolidBrush*)m_brush.get(), m_globalAlpha);
	} else if(dynamic_cast<Gdiplus::LinearGradientBrush*>(m_brush.get())) {
		ModifyLinearGradientBrush((LinearGradientBrush*)m_brush.get(), m_globalAlpha);
	}
}

void CanvasRenderingContext2D::FillRect(INT x, INT y, INT width, INT height) {
	std::auto_ptr<Brush> oldBrush(m_brush->Clone());
	this->UpdateBrushWithGlobalAlpha();
	m_graphics->FillRectangle(m_brush.get(), x, y, width, height);
	m_brush = oldBrush;
}

void CanvasRenderingContext2D:: StrokeRect(INT x, INT y, INT width, INT height) {
	std::auto_ptr<Pen> oldPen(m_pen->Clone());
	ModifyObjectAlpha(m_pen.get(), m_globalAlpha);
	m_graphics->DrawRectangle(m_pen.get(), x, y, width, height);				
	m_pen = oldPen;
}

const WCHAR* CanvasRenderingContext2D::GetLineJoin(){
	switch((*m_pen).GetLineJoin()){
		case Gdiplus::LineJoinBevel:
			return node::canvas::LineJoinBevel;
				
		case Gdiplus::LineJoinMiter:
			return node::canvas::LineJoinMiter;
				
		case Gdiplus::LineJoinRound:
			return node::canvas::LineJoinRound;				
	}

	return NULL;
}

void  CanvasRenderingContext2D::SetLineJoin(const WCHAR* join){
	if(!_wcsicmp(join, node::canvas::LineJoinBevel)){
		(*m_pen).SetLineJoin(Gdiplus::LineJoinBevel);
	} else if(!_wcsicmp(join, node::canvas::LineJoinMiter)){
		(*m_pen).SetLineJoin(Gdiplus::LineJoinMiter);
	} else if(!_wcsicmp(join, node::canvas::LineJoinRound)){
		(*m_pen).SetLineJoin(Gdiplus::LineJoinRound);
	}
}

const WCHAR*  CanvasRenderingContext2D::GetLineCap(){
	switch((*m_pen).GetStartCap()){
		case Gdiplus::LineCapRound:
			return node::canvas::LineCapRound;
				
		case Gdiplus::LineCapSquare:
			return node::canvas::LineCapSquare;
				
		case Gdiplus::LineCapFlat:
			return node::canvas::LineCapButt;				
	}

	return NULL;
}

void  CanvasRenderingContext2D::SetLineCap(const WCHAR* cap){
	if(!_wcsicmp(cap, node::canvas::LineCapRound)){
		(*m_pen).SetLineCap(Gdiplus::LineCapRound, Gdiplus::LineCapRound, Gdiplus::DashCapFlat);
	} else if(!_wcsicmp(cap, node::canvas::LineCapButt)){
		(*m_pen).SetLineCap(Gdiplus::LineCapFlat, Gdiplus::LineCapFlat, Gdiplus::DashCapFlat);
	} else if(!_wcsicmp(cap, node::canvas::LineCapSquare)){
		(*m_pen).SetLineCap(Gdiplus::LineCapSquare, Gdiplus::LineCapSquare, Gdiplus::DashCapFlat);
	}
}

INT  CanvasRenderingContext2D::GetLineWidth(){
	return m_pen->GetWidth();
}

void  CanvasRenderingContext2D::SetLineWidth(INT value){
	m_pen->SetWidth(value);
	m_lineWidth = value;
}

REAL CanvasRenderingContext2D::GetGlobalAlpha(){
	return m_globalAlpha;
}

void CanvasRenderingContext2D::SetGlobalAlpha(REAL value){
	m_globalAlpha = value;
}

void  CanvasRenderingContext2D::DrawImage(ImageSource* imageSource, INT dx, INT dy){
	Gdiplus::Image* image = imageSource->GetImage();
	m_graphics->DrawImage(image, dx, dy);
}

void CanvasRenderingContext2D::DrawImage(ImageSource* imageSource, INT dx, INT dy, INT dw, INT dh){
	Gdiplus::Image* image = imageSource->GetImage();
	m_graphics->DrawImage(image, dx, dy, dw, dh);
}

void CanvasRenderingContext2D::DrawImage(ImageSource* imageSource,  INT sx, INT sy, INT sw, INT sh, INT dx, INT dy, INT dw, INT dh){
	Gdiplus::Image* image = imageSource->GetImage();
	m_graphics->DrawImage(image, Gdiplus::RectF(dx, dy, dw, dh), sx, sy, sw, sh, UnitPixel);
}

void CanvasRenderingContext2D::Scale(REAL x, REAL y){
	m_graphics->ScaleTransform(x, y);
}

void CanvasRenderingContext2D::Rotate(REAL angle){
	m_graphics->RotateTransform(angle * 180 / M_PI);
}

void CanvasRenderingContext2D::Translate(REAL x, REAL y){
	m_graphics->TranslateTransform(x, y);
}

void CanvasRenderingContext2D::Transform(REAL a, REAL b, REAL c, REAL d, REAL e, REAL f){
	m_graphics->MultiplyTransform(&Gdiplus::Matrix(a, c, b, d, e, f));
}

void CanvasRenderingContext2D::SetTransform(REAL a, REAL b, REAL c, REAL d, REAL e, REAL f){
	m_graphics->SetTransform(&Gdiplus::Matrix(a, c, b, d, e, f));	
}

Gdiplus::Color ParseHexColor(const std::wstring& color){
	std::wstring numberStr = color.substr(1, color.size() - 1);
	int intColor;
	if(numberStr.length() == 3){
		wchar_t newStr[6] = {numberStr[0], numberStr[0], numberStr[1], numberStr[1], numberStr[2], numberStr[2]};
		numberStr = std::wstring(newStr); 
	}
	
	intColor = 0xff000000 | std::stoi(numberStr, 0, 16);
	return Color(intColor);	
}

Gdiplus::Color ParseRgbColor(const std::wstring& color){
	std::wstring numberStr = color.substr(4, color.size() - 5);
	size_t pos = numberStr.find(L",");
	BYTE r = std::stoi(numberStr.substr(0, pos));
	int oldPos = pos;
	pos = numberStr.find(L",", pos + 1);
	BYTE g = std::stoi(numberStr.substr(oldPos+1, pos - oldPos - 1));
	oldPos = pos;
	pos = numberStr.find(L")", pos + 1);
	BYTE b = std::stoi(numberStr.substr(oldPos+1, pos - oldPos - 1));	
	return Color(r, g, b);
}

Gdiplus::Color ParseRgbaColor(const std::wstring& color){
	int oldPos = 4;
	size_t pos = color.find(L",", oldPos);
	BYTE r = std::stoi(color.substr(oldPos+1, pos - oldPos - 1));
	oldPos = pos;
	pos = color.find(L",", pos + 1);
	BYTE g = std::stoi(color.substr(oldPos+1, pos - oldPos - 1));

	oldPos = pos;
	pos = color.find(L",", pos + 1);
	BYTE b = std::stoi(color.substr(oldPos+1, pos - oldPos - 1));	

	oldPos = pos;
	pos = color.find(L")", pos + 1);
	BYTE a = 255*std::stof(color.substr(oldPos+1, pos - oldPos - 1));	
	return Color(a, r, g, b);
}

Color CanvasRenderingContext2D::GetColorFromString(const WCHAR *value){
	std::wstring color = value;
	std::transform(color.begin(), color.end(), color.begin(), towlower);
	Gdiplus::Color gdiColor;
	if(color[0] == L'#'){
		gdiColor = ParseHexColor(color);		
	} else if(color.find(L"rgb(") == 0){
		gdiColor = ParseRgbColor(color);
	} else if(color.find(L"rgba(") == 0){
		gdiColor = ParseRgbaColor(color);
	} else {
		std::map<std::wstring, std::wstring>::iterator it = m_cssColors.find(color);
		if (it != m_cssColors.end()){
			gdiColor = GetColorFromString(it->second.c_str());			
		}				
	}

	return gdiColor;
}

void CanvasRenderingContext2D::SetStrokeColor(const WCHAR *value){	
	Gdiplus::Color gdiColor = GetColorFromString(value);	
	m_pen.reset(new Pen(gdiColor, m_lineWidth));
}

void CanvasRenderingContext2D::SetFillColor(const WCHAR *value){
	Gdiplus::Color gdiColor = GetColorFromString(value);	
	m_brush.reset(new SolidBrush(gdiColor));
}

std::auto_ptr<Brush> CanvasRenderingContext2D::BrushFromGradient(const CanvasGradient* grad){
	std::auto_ptr<LinearGradientBrush> brush(
			new LinearGradientBrush(
				Point(grad->X0, grad->Y0), Point(grad->X1, grad->Y1)
				, Color::Black, Color::White));
	
	int count = grad->ColorStops.size();
	std::vector<Color> colors;
	std::vector<REAL> positions;
	
	if(grad->ColorStops[0].position != 0){
		colors.push_back(this->GetColorFromString(grad->ColorStops[0].color.c_str()));
		positions.push_back(0);
	}
	
	for(int i = 0; i < count; ++i){
		colors.push_back(this->GetColorFromString(grad->ColorStops[i].color.c_str()));
		positions.push_back(grad->ColorStops[i].position);
	}

	if(grad->ColorStops[count-1].position != 1){
		colors.push_back(this->GetColorFromString(grad->ColorStops[count-1].color.c_str()));
		positions.push_back(1);
	}

	brush->SetInterpolationColors(&colors[0], &positions[0], colors.size());

	return brush;
}

void CanvasRenderingContext2D::SetGradientFill(const CanvasGradient* grad){
	m_brush = this->BrushFromGradient(grad);
}

void CanvasRenderingContext2D::SetGradientStroke(const CanvasGradient* grad){
	std::auto_ptr<Brush> brush = this->BrushFromGradient(grad);
	m_pen.reset(new Pen(brush.get(), m_lineWidth));
}

const WCHAR* CanvasRenderingContext2D::GetFont(){
	return m_fontString.c_str();
}

std::vector<std::wstring> TokenizeString(const WCHAR* value){
	std::vector<std::wstring> tokens;
	int len = wcslen(value);
	int left = 0;
	int right = 0;
	bool quote = false;
	for(int i = 0; i < len; ++i){		
		if(value[i] == L'"'){
			quote = !quote;
		} else {
			if((value[i] == L' ' || value[i] == L',') && !quote){
				std::wstring token = std::wstring(&value[left], &value[i]);	
				std::transform(token.begin(), token.end(), token.begin(), towlower);
				tokens.push_back(token);
				while(value[i++] == L' ')
					;
				left=--i;
			}
			right = i;
		}
	}
	if(value[left] == L'"')left++;
	std::wstring token = std::wstring(&value[left], &value[right+1]);	
	std::transform(token.begin(), token.end(), token.begin(), towlower);
	tokens.push_back(token);

	return tokens;
}

bool IsPixeUnit(const std::wstring& value){
	size_t size = value.size();
	return value.find(L"px") == size-2;
}

bool IsPointUnit(const std::wstring& value){
	size_t size = value.size();
	return value.find(L"pt") == size-2;
}

bool IsUnitNumber(const std::wstring& value){
	return IsPixeUnit(value) || IsPointUnit(value);
}

void CanvasRenderingContext2D::SetFont(const WCHAR* value){
	m_fontString = value;
	std::vector<std::wstring> tokens = TokenizeString(value);
	bool style = 0;
	Unit unit = UnitPixel;
	float size = 10;
	int weight = 300;
	std::vector<std::wstring> families;

	std::wstring bold(L"bold");
	std::wstring italic(L"italic");
	std::wstring normal(L"normal");

	for(std::vector<std::wstring>::iterator it = tokens.begin(); it != tokens.end(); ++it){
		if(*it == bold){
			style |= FontStyleBold;
		} else if(*it == italic){
			style |= FontStyleItalic;
		} else if(*it == normal){
			
		}else if(IsUnitNumber(*it)){
			size = std::stof(*it);
			if(IsPixeUnit(*it)) unit = UnitPixel;
			else if(IsPointUnit(*it)) unit = UnitPoint;
		} else {
			size_t ps = 0;
			try{
				int n = std::stoi(*it, &ps);
				if(ps > 0){
					weight = n;
				} 
			}
			catch(...)
			{
				families.push_back(*it);
			}
		}
	}
	families.push_back(L"sans-serief");
	std::wstring familyName;
	for(std::vector<std::wstring>::iterator it = families.begin(); it != families.end(); ++it){
		FontFamily family(it->c_str());
		if(family.IsAvailable()){
			familyName = *it;			
			break;
		}
	}
		
	m_font.reset(new Font(familyName.c_str(), size, style, unit));	
}


const WCHAR* CanvasRenderingContext2D::GetTextAlign(){
	switch(m_stringFormat->GetAlignment()){
	case StringAlignmentNear:
		return TextAlignStart;
	case StringAlignmentCenter:
		return TextAlignCenter;
	case StringAlignmentFar:
		return TextAlignEnd;
	}
}

void CanvasRenderingContext2D::SetTextAlign(const WCHAR* value){
	if(!_wcsicmp(value, node::canvas::TextAlignStart)){
		m_stringFormat->SetAlignment(StringAlignmentNear);
	} if(!_wcsicmp(value, node::canvas::TextAlignCenter)){
		m_stringFormat->SetAlignment(StringAlignmentCenter);
	} if(!_wcsicmp(value, node::canvas::TextAlignEnd)){
		m_stringFormat->SetAlignment(StringAlignmentFar);
	}
}
const WCHAR* CanvasRenderingContext2D::GetTextBaseline(){
	switch(m_stringFormat->GetAlignment()){
	case StringAlignmentNear:
		return TextAlignTop;
	case StringAlignmentCenter:
		return TextAlignMiddle;
	case StringAlignmentFar:
		return TextAlignBottom;
	}	
}

void CanvasRenderingContext2D::SetTextBaseline(const WCHAR* value){
	if(!_wcsicmp(value, node::canvas::TextAlignTop)){
		m_stringFormat->SetLineAlignment(StringAlignmentNear);
	} if(!_wcsicmp(value, node::canvas::TextAlignMiddle)){
		m_stringFormat->SetLineAlignment(StringAlignmentCenter);
	} if(!_wcsicmp(value, node::canvas::TextAlignBottom)){
		m_stringFormat->SetLineAlignment(StringAlignmentFar);
	}
}

RectF CanvasRenderingContext2D::MeasureText(const WCHAR* text){
	RectF rect(0,0, 1000, 1000);
	StringFormat* format = m_stringFormat->Clone();
	unsigned int length = wcslen(text);
	CharacterRange range(0, length);
	Region region;
	format->SetMeasurableCharacterRanges(1, &range);
	format->SetFormatFlags( StringFormatFlagsMeasureTrailingSpaces | StringFormatFlagsNoWrap | StringFormatFlagsNoClip);
	m_graphics->MeasureCharacterRanges(text, length, m_font.get(), rect, format, 1, &region);
	region.GetBounds(&rect, m_graphics.get());
	delete format;
	return rect;
}

void CanvasRenderingContext2D::FillText(const WCHAR* text, double x, double y, REAL maxWidth){
	GraphicsPath textPath;
	FontFamily family;
	m_font->GetFamily(&family);
	float size = m_font->GetSize();
	
	textPath.AddString(text, wcslen(text), &family, m_font->GetStyle(), size, PointF(x, y), m_stringFormat.get());

	std::auto_ptr<Brush> oldBrush(m_brush->Clone());
	this->UpdateBrushWithGlobalAlpha();
	m_graphics->FillPath(m_brush.get(), &textPath);
	m_brush = oldBrush;	
}

void CanvasRenderingContext2D::StrokeText(const WCHAR* text, double x, double y, REAL maxWidth){
	GraphicsPath textPath;
	FontFamily family;
	m_font->GetFamily(&family);
	textPath.AddString(text, wcslen(text), &family, m_font->GetStyle(), m_font->GetSize(), PointF(x, y), m_stringFormat.get());

	std::auto_ptr<Pen> oldPen(m_pen->Clone());
	ModifyObjectAlpha(m_pen.get(), m_globalAlpha);
	m_graphics->DrawPath(m_pen.get(), &textPath);
	m_pen = oldPen;	
}

void CanvasRenderingContext2D::Init(Handle<Object> target){
	HandleScope scope;

	// Constructor
	constructor = Persistent<FunctionTemplate>::New(FunctionTemplate::New(CanvasRenderingContext2D::New));
	constructor->InstanceTemplate()->SetInternalFieldCount(1);
	constructor->SetClassName(String::NewSymbol("CanvasRenderingContext2D"));

	// Prototype
	Local<ObjectTemplate> proto = constructor->PrototypeTemplate();
	NODE_SET_PROTOTYPE_METHOD(constructor, "saveToFile", SaveToFile);
	NODE_SET_PROTOTYPE_METHOD(constructor, "moveTo", MoveTo);
	NODE_SET_PROTOTYPE_METHOD(constructor, "lineTo", LineTo);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "fill", Fill);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "stroke", Stroke);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "closePath", ClosePath);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "beginPath", BeginPath);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "clip", Clip);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "clearRect", ClearRect);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "fillRect", FillRect);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "strokeRect", StrokeRect);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "arc", Arc);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "rect", Rect);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "bezierCurveTo", BezierCurveTo);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "quadraticCurveTo", QuadraticCurveTo);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "save", Save);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "restore", Restore);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "drawImage", DrawImage);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "scale", Scale);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "rotate", Rotate);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "translate", Translate);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "transform", Transform);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "setTransform", SetTransform);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "createLinearGradient", CreateLinearGradient);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "createPattern", CreatePattern);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "fillText", FillText);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "strokeText", StrokeText);	
	NODE_SET_PROTOTYPE_METHOD(constructor, "measureText", MeasureText);

	proto->SetAccessor(String::NewSymbol("lineWidth"), GetLineWidth, SetLineWidth);
	proto->SetAccessor(String::NewSymbol("lineJoin"), GetLineJoin, SetLineJoin);
	proto->SetAccessor(String::NewSymbol("lineCap"), GetLineCap, SetLineCap);

	proto->SetAccessor(String::NewSymbol("strokeStyle"), GetStrokeStyle, SetStrokeStyle);
	proto->SetAccessor(String::NewSymbol("fillStyle"), GetFillStyle, SetFillStyle);

	proto->SetAccessor(String::NewSymbol("font"), GetFont, SetFont);
	proto->SetAccessor(String::NewSymbol("textAlign"), GetTextAlign, SetTextAlign);
	proto->SetAccessor(String::NewSymbol("textBaseline"), GetTextBaseline, SetTextBaseline);
	proto->SetAccessor(String::NewSymbol("globalAlpha"), GetGlobalAlpha, SetGlobalAlpha);
				
	target->Set(String::NewSymbol("CanvasRenderingContext2D"), constructor->GetFunction());

	GdiplusStartupInput gdiplusStartupInput;				
	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
}

 Handle<Value> CanvasRenderingContext2D::New(const Arguments& args)
{
	HandleScope scope;
	CanvasRenderingContext2D* context = new CanvasRenderingContext2D();
	context->Wrap(args.This());
	return args.This();
}	

 Handle<Value> CanvasRenderingContext2D::SaveToFile(const Arguments& args)
{
	HandleScope scope;				
	CanvasRenderingContext2D* context = UnwrapContext(args);
	Local<Value> result;
				
	// getthe param
	v8::String::Value fileNameParam(args[0]->ToString());
	v8::String::Value formatParam(args[1]->ToString());

	// convert it to string
	std::wstring fileName = std::wstring(reinterpret_cast<wchar_t*>(*fileNameParam));   
	std::wstring format = std::wstring(reinterpret_cast<wchar_t*>(*formatParam));   

	CLSID pngClsid;
	GetEncoderClsid(format.c_str(), &pngClsid);
	Status st = context->m_buffer->Save(fileName.c_str(), &pngClsid);
				
	return scope.Close(Number::New(GetLastError()));
}

 Handle<Value> CanvasRenderingContext2D::MoveTo(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "moveTo() x must be a number"); 
	ARG_IS_NUMBER(1, "moveTo() y must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->MoveTo(args[0]->NumberValue(), args[1]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::LineTo(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "lineTo() x must be a number"); 
	ARG_IS_NUMBER(1, "lineTo() y must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->LineTo(args[0]->NumberValue(), args[1]->NumberValue());

	return Undefined();
}

Handle<Value>  CanvasRenderingContext2D::ClearRect(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "clearRect() x must be a number"); 
	ARG_IS_NUMBER(1, "clearRect() y must be a number"); 
	ARG_IS_NUMBER(2, "clearRect() width must be a number"); 
	ARG_IS_NUMBER(3, "clearRect() height must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->ClearRect(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::FillRect(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "fillRect() x must be a number"); 
	ARG_IS_NUMBER(1, "fillRect() y must be a number"); 
	ARG_IS_NUMBER(2, "fillRect() width must be a number"); 
	ARG_IS_NUMBER(3, "fillRect() height must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->FillRect(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::StrokeRect(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "strokeRect() x must be a number"); 
	ARG_IS_NUMBER(1, "strokeRect() y must be a number"); 
	ARG_IS_NUMBER(2, "strokeRect() width must be a number"); 
	ARG_IS_NUMBER(3, "strokeRect() height must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->StrokeRect(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::Rect(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "rect() x must be a number"); 
	ARG_IS_NUMBER(1, "rect() y must be a number"); 
	ARG_IS_NUMBER(2, "rect() width must be a number"); 
	ARG_IS_NUMBER(3, "rect() height must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Rect(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::Arc(const Arguments& args){
	HandleScope scope;

	ARG_IS_NUMBER(0, "arc() x must be a number"); 
	ARG_IS_NUMBER(1, "arc() y must be a number"); 
	ARG_IS_NUMBER(2, "arc() radius must be a number"); 
	ARG_IS_NUMBER(3, "arc() startAngle must be a number"); 
	ARG_IS_NUMBER(4, "arc() endAngle must be a number"); 
	bool anitclockwise = FALSE;
	if(args.Length() == 6){
		anitclockwise = args[5]->BooleanValue();
	}
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Arc(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue(), anitclockwise);

	return Undefined();
}

// TODO: implement ArcTo

 Handle<Value> CanvasRenderingContext2D::BezierCurveTo(const Arguments& args){
	HandleScope scope;
				
	ARG_IS_NUMBER(0, "bezierCurveTo() cp1x must be a number"); 
	ARG_IS_NUMBER(1, "bezierCurveTo() cp1y must be a number"); 
	ARG_IS_NUMBER(2, "bezierCurveTo() cp2x must be a number"); 
	ARG_IS_NUMBER(3, "bezierCurveTo() cp2y must be a number"); 
	ARG_IS_NUMBER(4, "bezierCurveTo() x must be a number"); 
	ARG_IS_NUMBER(5, "bezierCurveTo() y must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->BezierCurveTo(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue(), args[5]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::QuadraticCurveTo(const Arguments& args){
	HandleScope scope;
				
	ARG_IS_NUMBER(0, "quadraticCurveTo() cpx must be a number"); 
	ARG_IS_NUMBER(1, "quadraticCurveTo() cpy must be a number"); 
	ARG_IS_NUMBER(2, "quadraticCurveTo() x must be a number"); 
	ARG_IS_NUMBER(3, "quadraticCurveTo() y must be a number"); 
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->QuadraticCurveTo(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());

	return Undefined();
}

 Handle<Value> CanvasRenderingContext2D::DrawImage(const Arguments& args){
	HandleScope scope;
				
	if (args.Length() < 3){
		return ThrowException(Exception::TypeError(String::New("invalid arguments")));
	}

	if(!args[0]->IsObject()){
		return ThrowException(Exception::TypeError(String::New("drawImage image must be a Image or Canvas")));
	}

	Local<Object> obj = args[0]->ToObject();
	ImageSource* imageSource;
	// Image
	if (Image::constructor->HasInstance(obj)) {
		Image *img = ObjectWrap::Unwrap<Image>(obj);
		if (!img->GetComplete()) {
			return ThrowException(Exception::Error(String::New("Image given has not completed loading")));
		}
					
		imageSource = (ImageSource*)(img);					
	} else if (Canvas::constructor->HasInstance(obj)) {
		Canvas *canvas = ObjectWrap::Unwrap<Canvas>(obj);
		imageSource = (ImageSource*)(canvas);
	} else {
		return ThrowException(Exception::TypeError(String::New("drawImage image must be a Image or Canvas")));
	}
				
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	if(args.Length() == 3){
		ARG_IS_NUMBER(1, "drawImage() dx must be a number"); 
		ARG_IS_NUMBER(2, "drawImage() dy must be a number"); 
		context->DrawImage(imageSource,  args[1]->NumberValue(), args[2]->NumberValue());
	} else if(args.Length() == 5){
		ARG_IS_NUMBER(1, "drawImage() dx must be a number"); 
		ARG_IS_NUMBER(2, "drawImage() dy must be a number"); 
		ARG_IS_NUMBER(3, "drawImage() dw must be a number"); 
		ARG_IS_NUMBER(4, "drawImage() dh must be a number"); 
		context->DrawImage(imageSource,  args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue());
	}  else if(args.Length() == 9){
		ARG_IS_NUMBER(1, "drawImage() sx must be a number"); 
		ARG_IS_NUMBER(2, "drawImage() sy must be a number"); 
		ARG_IS_NUMBER(3, "drawImage() sw must be a number"); 
		ARG_IS_NUMBER(4, "drawImage() sh must be a number"); 
		ARG_IS_NUMBER(5, "drawImage() dx must be a number"); 
		ARG_IS_NUMBER(6, "drawImage() dy must be a number"); 
		ARG_IS_NUMBER(7, "drawImage() dw must be a number"); 
		ARG_IS_NUMBER(8, "drawImage() dh must be a number"); 
		context->DrawImage(imageSource,  args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue(), args[5]->NumberValue(), args[6]->NumberValue(), args[7]->NumberValue(), args[8]->NumberValue());
	}

	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::Scale(const Arguments& args){
	ARG_IS_NUMBER(0, "scale() x must be a number"); 
	ARG_IS_NUMBER(1, "scale() y must be a number"); 
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Scale(args[0]->NumberValue(), args[1]->NumberValue());
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::Rotate(const Arguments& args){
	ARG_IS_NUMBER(0, "rotate() angle must be a number"); 	
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());	
	context->Rotate(args[0]->NumberValue());
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::Translate(const Arguments& args){
	ARG_IS_NUMBER(0, "translate() x must be a number"); 
	ARG_IS_NUMBER(1, "translate() y must be a number"); 
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Translate(args[0]->NumberValue(), args[1]->NumberValue());
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::Transform(const Arguments& args){
	ARG_IS_NUMBER(0, "scale() a must be a number"); 
	ARG_IS_NUMBER(1, "scale() b must be a number"); 
	ARG_IS_NUMBER(2, "scale() c must be a number"); 
	ARG_IS_NUMBER(3, "scale() d must be a number"); 
	ARG_IS_NUMBER(4, "scale() e must be a number"); 
	ARG_IS_NUMBER(5, "scale() f must be a number"); 
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Transform(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue(), args[5]->NumberValue());
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::SetTransform(const Arguments& args){
	ARG_IS_NUMBER(0, "scale() a must be a number"); 
	ARG_IS_NUMBER(1, "scale() b must be a number"); 
	ARG_IS_NUMBER(2, "scale() c must be a number"); 
	ARG_IS_NUMBER(3, "scale() d must be a number"); 
	ARG_IS_NUMBER(4, "scale() e must be a number"); 
	ARG_IS_NUMBER(5, "scale() f must be a number"); 
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Transform(args[0]->NumberValue(), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue(), args[4]->NumberValue(), args[5]->NumberValue());
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::CreateLinearGradient(const Arguments& args){
	HandleScope scope;
	if(args.Length() == 4){
		ARG_IS_NUMBER(0, "createLinearGradient() x0 must be a number"); 
		ARG_IS_NUMBER(1, "createLinearGradient() y0 must be a number"); 
		ARG_IS_NUMBER(2, "createLinearGradient() x1 must be a number"); 
		ARG_IS_NUMBER(3, "createLinearGradient() y1 must be a number"); 
	}
	
	Handle<Value> gradInstance = CanvasGradient::NewInstance(args);
	
	return scope.Close(gradInstance);
}

Handle<Value> CanvasRenderingContext2D::CreatePattern(const Arguments& args){
	HandleScope scope;

	Local<Object> obj = args[0]->ToObject();
	ImageSource* imageSource;
	if (Image::constructor->HasInstance(obj)) {
		Image *img = ObjectWrap::Unwrap<Image>(obj);
		if (!img->GetComplete()) {
			return ThrowException(Exception::Error(String::New("Image given has not completed loading")));
		}
	} else if (!Canvas::constructor->HasInstance(obj)) {
		return ThrowException(Exception::TypeError(String::New("createPattern image must be an Image or Canvas")));
	}

	ARG_IS_STRING(1, "CreatePattern() repetition must be a string"); 
	
	Handle<Value> pattern = CanvasPattern::NewInstance(args);
	
	return scope.Close(pattern);
}

Handle<Value> CanvasRenderingContext2D::ResetTransform(const Arguments& args){
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	context->Transform(1, 0, 0, 1, 0, 0);
	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::GetStrokeStyle(Local<String> prop, const AccessorInfo &info) {
	HandleScope scope;
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(info.This());
	return context->m_strokeStyle;
}			
void CanvasRenderingContext2D::SetStrokeStyle(Local<String> prop, Local<Value> val, const AccessorInfo &info) {
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(info.This());
	if (val->IsString()) {		
		String::Value capValue(val->ToString());
		context->SetStrokeColor(reinterpret_cast<WCHAR*>(*capValue));
	} else if (val->IsObject()){
		Local<Object> obj = val->ToObject();
		if(CanvasGradient::constructor->HasInstance(obj)){
			CanvasGradient*  grad = ObjectWrap::Unwrap<CanvasGradient>(obj);
			context->SetGradientStroke(grad);
		}
	}
	context->m_strokeStyle.Dispose();
	context->m_strokeStyle = Persistent<Value>::New(val);
}

Handle<Value> CanvasRenderingContext2D::GetFillStyle(Local<String> prop, const AccessorInfo &info) {
	HandleScope scope;
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(info.This());
	return context->m_fillStyle;
}			
void CanvasRenderingContext2D::SetFillStyle(Local<String> prop, Local<Value> val, const AccessorInfo &info) {
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(info.This());
	HandleScope scope;
	if (val->IsString()) {		
		String::Value capValue(val->ToString());
		context->SetFillColor(reinterpret_cast<WCHAR*>(*capValue));
	} else if (val->IsObject()){
		Local<Object> obj = val->ToObject();
		if(CanvasGradient::constructor->HasInstance(obj)){
			CanvasGradient*  grad = ObjectWrap::Unwrap<CanvasGradient>(obj);
			context->SetGradientFill(grad);
		} else if(CanvasPattern::constructor->HasInstance(obj)){
			CanvasPattern*  pattern = ObjectWrap::Unwrap<CanvasPattern>(obj);
			context->m_brush.reset(pattern->GetBrush());// TODO: apply global alpha
		}
	}
	context->m_fillStyle.Dispose();
	context->m_fillStyle = Persistent<Value>::New(val);
}

METHOD_NOARGS(Fill, CanvasRenderingContext2D)
METHOD_NOARGS(Stroke, CanvasRenderingContext2D)
METHOD_NOARGS(ClosePath, CanvasRenderingContext2D)
METHOD_NOARGS(BeginPath, CanvasRenderingContext2D)
METHOD_NOARGS(Clip, CanvasRenderingContext2D)
METHOD_NOARGS(Save, CanvasRenderingContext2D)
METHOD_NOARGS(Restore, CanvasRenderingContext2D)
			
NUMBERPROP(LineWidth, CanvasRenderingContext2D)
REALNUMBERPROP(GlobalAlpha, CanvasRenderingContext2D)
STRINGPROP(LineJoin, CanvasRenderingContext2D)
STRINGPROP(LineCap, CanvasRenderingContext2D)	
STRINGPROP(Font, CanvasRenderingContext2D)	
STRINGPROP(TextAlign, CanvasRenderingContext2D)	
STRINGPROP(TextBaseline, CanvasRenderingContext2D)	

Handle<Value> CanvasRenderingContext2D::FillText(const Arguments& args){
	ARG_IS_STRING(0, "fillText() text must be a string"); 
	ARG_IS_NUMBER(1, "fillText() x must be a number"); 
	ARG_IS_NUMBER(2, "fillText() y must be a number"); 
	HandleScope scope;

	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	String::Value text(args[0]);

	if(args.Length() == 3){
		context->FillText(reinterpret_cast<WCHAR*>(*text), args[1]->NumberValue(), args[2]->NumberValue(), 0);
	} else if(args.Length() == 4){
		ARG_IS_NUMBER(3, "fillText() maxWidth must be a number"); 
		context->FillText(reinterpret_cast<WCHAR*>(*text), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());
	}

	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::StrokeText(const Arguments& args){
	ARG_IS_STRING(0, "strokeText() text must be a string"); 
	ARG_IS_NUMBER(1, "strokeText() x must be a number"); 
	ARG_IS_NUMBER(2, "strokeText() y must be a number"); 
	HandleScope scope;

	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	String::Value text(args[0]);

	if(args.Length() == 3){
		context->StrokeText(reinterpret_cast<WCHAR*>(*text), args[1]->NumberValue(), args[2]->NumberValue(), 0);
	} else if(args.Length() == 4){
		ARG_IS_NUMBER(3, "strokeText() maxWidth must be a number"); 
		context->StrokeText(reinterpret_cast<WCHAR*>(*text), args[1]->NumberValue(), args[2]->NumberValue(), args[3]->NumberValue());
	}

	return Undefined();
}

Handle<Value> CanvasRenderingContext2D::MeasureText(const Arguments& args){
	HandleScope scope;
	ARG_IS_STRING(0, "measureText() text must be a string"); 
	CanvasRenderingContext2D *context = ObjectWrap::Unwrap<CanvasRenderingContext2D>(args.This());
	String::Value text(args[0]);
	RectF rect = context->MeasureText(reinterpret_cast<WCHAR*>(*text));
	Handle<Value> mt = TextMetrics::NewInstance(rect.Width, rect.Height);
	return scope.Close(mt);
}
