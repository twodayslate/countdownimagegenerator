#include "stdafx.h"

#include "v8helper.h"
#include "ImageSource.h"
#include "Image.h"


using namespace v8;
using namespace node::canvas;
using namespace node;

Persistent<FunctionTemplate> Image::constructor;

#define BUFSIZE 4096

bool FileExists(const TCHAR *fileName)
{
    DWORD       fileAttr;

    fileAttr = GetFileAttributes(fileName);
    if (0xFFFFFFFF == fileAttr)
        return false;
    return true;
}

void Image::LoadImage(const std::wstring &source){
	HandleScope scope;
	m_source = source;

	WCHAR  buffer[BUFSIZE]=TEXT(""); 
    WCHAR** lppPart={NULL};

	GetFullPathName(source.c_str(), BUFSIZE, buffer, lppPart);

	if(!FileExists(buffer)){
		OnError(String::New("file not found"));
		return;
	}
	Gdiplus::Image *img = Gdiplus::Image::FromFile(buffer);
	m_image.reset(img);
	Gdiplus::SizeF size;
	m_image->GetPhysicalDimension(&size);
	V8::AdjustAmountOfExternalAllocatedMemory(size.Width * size.Height); // TODO: adjust back when image is freed
	m_completed = true;
	OnLoad();
}

void Image::OnLoad(){
	if (!this->onload.IsEmpty()) {
		TryCatch try_catch;
		this->onload->Call(Context::GetCurrent()->Global(), 0, NULL);
		this->onload.Dispose();
		if (try_catch.HasCaught()) {
			OnError(try_catch.Exception());
		}
	}
}

void Image::OnError(Local<Value> err) {
	HandleScope scope;
	if (!this->onerror.IsEmpty()) {
		Local<Value> argv[1] = { err };
		TryCatch try_catch;
		this->onerror->Call(Context::GetCurrent()->Global(), 1, argv);
		this->onerror.Dispose();
		if (try_catch.HasCaught()) {
			FatalException(try_catch);
		}
	}
}

const WCHAR* Image::GetSource(){
	return NULL;
}

void Image::SetSource(const WCHAR* value){
	std::wstring source = std::wstring(value);
	if(source != m_source){					
		LoadImage(source);
	}
}

INT Image::GetWidth(){
	if(m_image.get() == NULL){
		return 0;
	}

	return m_image->GetWidth();
}

INT Image::GetHeight(){
	if(m_image.get() == NULL){
		return 0;
	}

	return m_image->GetHeight();
}

bool Image::GetComplete(){
	return m_completed;
}

Gdiplus::Image* Image::GetImage(){
	return m_image.get();
}

void Image::Init(Handle<Object> target)
{
	HandleScope scope;

	// Constructor
	constructor = Persistent<FunctionTemplate>::New(FunctionTemplate::New(Image::New));
	constructor->InstanceTemplate()->SetInternalFieldCount(1);
	constructor->SetClassName(String::NewSymbol("Image"));

	// Prototype
	Local<ObjectTemplate> proto = constructor->PrototypeTemplate();
	proto->SetAccessor(String::NewSymbol("source"), GetSource, SetSource);
	proto->SetAccessor(String::NewSymbol("src"), GetSource, SetSource);
	proto->SetAccessor(String::NewSymbol("complete"), GetComplete);
	proto->SetAccessor(String::NewSymbol("width"), GetWidth);
	proto->SetAccessor(String::NewSymbol("height"), GetHeight);
	proto->SetAccessor(String::NewSymbol("onload"), GetOnload, SetOnload);
	proto->SetAccessor(String::NewSymbol("onerror"), GetOnerror, SetOnerror);				
				
	target->Set(String::NewSymbol("Image"), constructor->GetFunction());
}

Handle<Value> Image::New(const Arguments& args)
{
	HandleScope scope;
	node::canvas::Image* image = new node::canvas::Image();
	image->Wrap(args.This());
	return args.This();
}

STRINGPROP(Source, Image)
NUMBERPROP_GET(Width, Image)
NUMBERPROP_GET(Height, Image)
BOOLPROP_GET(Complete, Image)

Handle<Value> Image::GetOnload(Local<String>, const AccessorInfo &info) {
#if _DEBUG // need this because of the issue with WebStorm node debugger
	if(info.This()->InternalFieldCount() == 0){
		return Undefined();
	}
#endif
	Image *img = ObjectWrap::Unwrap<Image>(info.This());
	return img->onload;
}
			
void Image::SetOnload(Local<String>, Local<Value> val, const AccessorInfo &info) {
	if (val->IsFunction()) {
		Image *img = ObjectWrap::Unwrap<Image>(info.This());
		img->onload = Persistent<Function>::New(Handle<Function>::Cast(val));
	}
}

Handle<Value> Image::GetOnerror(Local<String>, const AccessorInfo &info) {
#if _DEBUG // need this because of the issue with WebStorm node debugger
	if(info.This()->InternalFieldCount() == 0){
		return Undefined();
	}
#endif
	Image *img = ObjectWrap::Unwrap<Image>(info.This());
	return img->onerror;
}
			
void Image::SetOnerror(Local<String>, Local<Value> val, const AccessorInfo &info) {
	if (val->IsFunction()) {
		Image *img = ObjectWrap::Unwrap<Image>(info.This());
		img->onerror = Persistent<Function>::New(Handle<Function>::Cast(val));
	}
}
