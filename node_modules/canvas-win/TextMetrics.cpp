#include "StdAfx.h"
#include "TextMetrics.h"

using namespace v8;
using namespace node;
using namespace node::canvas;

Persistent<FunctionTemplate> TextMetrics::constructor;

TextMetrics::TextMetrics(void)
{
}


TextMetrics::~TextMetrics(void)
{
}

void TextMetrics::Init(Handle<Object> target){
	HandleScope scope;

	// Constructor
	constructor = Persistent<FunctionTemplate>::New(FunctionTemplate::New(TextMetrics::New));
	constructor->InstanceTemplate()->SetInternalFieldCount(1);
	constructor->SetClassName(String::NewSymbol("TextMetrics"));

	// Prototype
	Local<ObjectTemplate> proto = constructor->PrototypeTemplate();
				
	proto->SetAccessor(String::NewSymbol("width"), GetWidth, SetWidth);	
	proto->SetAccessor(String::NewSymbol("height"), GetHeight, SetHeight);	
				
	target->Set(String::NewSymbol("TextMetrics"), constructor->GetFunction());
}

Handle<Value> TextMetrics::New(const Arguments& args){
	HandleScope scope;
	TextMetrics* tm = new TextMetrics();
	ARG_IS_NUMBER(0, "width should be a number");
	ARG_IS_NUMBER(1, "height should be a number");
	tm->m_width = (int)args[0]->NumberValue();
	tm->m_height = (int)args[1]->NumberValue();
	tm->Wrap(args.This());
	return args.This();
}

Handle<Value> TextMetrics::NewInstance(double width, double height) {
	HandleScope scope;

	const unsigned argc = 2;
	Handle<Value> argv[argc] ={Number::New(width), Number::New(height)};
		
	Local<Object> instance = constructor->GetFunction()->NewInstance(argc, argv);

	return scope.Close(instance);
}

double TextMetrics::GetWidth(){
	return m_width;
}

void TextMetrics::SetWidth(double value){
	m_width = value;
}

double TextMetrics::GetHeight(){
	return m_height;
}
void TextMetrics::SetHeight(double value){
	m_height = value;
}

NUMBERPROP(Width, TextMetrics)
NUMBERPROP(Height, TextMetrics)

