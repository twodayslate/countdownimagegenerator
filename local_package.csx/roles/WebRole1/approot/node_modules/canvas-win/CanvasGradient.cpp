#include "StdAfx.h"
#include "CanvasGradient.h"

using namespace node;
using namespace node::canvas;

Persistent<FunctionTemplate> CanvasGradient::constructor;

CanvasGradient::CanvasGradient(void)
{
}


CanvasGradient::~CanvasGradient(void)
{
}

void CanvasGradient::Init(Handle<Object> target){
	HandleScope scope;

	// Constructor
	constructor = Persistent<FunctionTemplate>::New(FunctionTemplate::New(CanvasGradient::New));
	constructor->InstanceTemplate()->SetInternalFieldCount(1);
	constructor->SetClassName(String::NewSymbol("CanvasGradient"));

	// Prototype
	NODE_SET_PROTOTYPE_METHOD(constructor, "addColorStop", AddColorStop);
	target->Set(String::NewSymbol("CanvasGradient"), constructor->GetFunction());
}

Handle<Value> CanvasGradient::NewInstance(const Arguments& args) {
	HandleScope scope;

	const unsigned argc = args.Length();
	Handle<Value> *argv = new Handle<Value>[argc];
	for(int i = 0; i<argc; ++i){
		argv[i] = args[i];
	}
	
	Local<Object> instance = constructor->GetFunction()->NewInstance(argc, argv);
	delete[] argv;

	return scope.Close(instance);
}

Handle<Value> CanvasGradient::New(const Arguments &args){
	HandleScope scope;

	// Linear
	if (4 == args.Length()) {
		CanvasGradient *grad = new CanvasGradient(
			args[0]->NumberValue()
			, args[1]->NumberValue()
			, args[2]->NumberValue()
			, args[3]->NumberValue());
		grad->Wrap(args.This());
		return args.This();
	}

	// Radial
	if (6 == args.Length()) {
		CanvasGradient *grad = new CanvasGradient(
			args[0]->NumberValue()
			, args[1]->NumberValue()
			, args[2]->NumberValue()
			, args[3]->NumberValue()
			, args[4]->NumberValue()
			, args[5]->NumberValue());
		grad->Wrap(args.This());
		return args.This();
	}
  
	return ThrowException(Exception::TypeError(String::New("invalid arguments")));
}

Handle<Value> CanvasGradient::AddColorStop(const Arguments &args){
	HandleScope scope;
	if (!args[0]->IsNumber()){ 
		return ThrowException(Exception::TypeError(String::New("offset required")));
	}
	if (!args[1]->IsString()){
		return ThrowException(Exception::TypeError(String::New("color string required")));
	}

	CanvasGradient *grad = ObjectWrap::Unwrap<CanvasGradient>(args.This());	
	String::Value color(args[1]);	
	grad->ColorStops.push_back(ColorStop(std::wstring(reinterpret_cast<WCHAR*>(*color)), args[0]->NumberValue()));

	return Undefined();
}

CanvasGradient::CanvasGradient(double x0, double y0, double x1, double y1)
	:X0(x0), Y0(y0), X1(x1), Y1(y1), m_isLinear(true){
	
}

CanvasGradient::CanvasGradient(double x0, double y0, double r0, double x1, double y1, double r1)
	:X0(x0), Y0(y0), X1(x1), Y1(y1), R0(r0), R1(r1), m_isLinear(false){
}

